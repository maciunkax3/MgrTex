\section[Wstęp do Api OpenCL]{Wstęp do Api OpenCL}
OpenCL czyli Open Compute Language to standard tworzony obecnie przez grupe Khronos, służący do pisania programów, kótre mogą zostać wykonane na różnych platformach takich jak CPU, GPU czy FPGA. Specyfikacja OpenCL definiuje interfejs w języku c++, który umożliwia zaprogramowanie aplikacji by ta wykonała konretny kod na wybranym urządeniu. Standard OpenCL jest głównie wykorzystywany do równoległych obliczeń takie jak wektorowe operacje matematyczne czy przetwarzanie obrazów. Za implementacje sterownika który wystawia api zgodne z określoną wersją specyfikacji odpowiedzialny jest producent urządzenia.  Dzięki temu, że standard jest otwarty a jego implementacje posiada większość producentów możemy stworzyć kod który możemy uruchomić niezależnie od architektury czy producenta posiadanego procesora głównego czy graficznego. Jest to duża zaleta w porównaniu na przykład do CUDA, która to jest interfejsem implementowanym jedynie przez Nvidie. Standard OpenCL jest rozwijany i modyfikowany, przez co api zdefiniowane jest w kilku wersjach. Najnowsza wersja specyfikacji to wersja 3.0. Wszystkie wersje są kompatybilne wstecznie. Dodatkowo zdefiniowane są rozszerzenia api takie jak cl\_khr\_gl\_sharing czy definiujący api do sharingu obiektów między OpenCL a OpenGL, takie dodatkowe api jest też specyfikowane przez grupę Khonosa w ramach określonej wersji OpenCL, jednak nie jest obowiązkowe. Istnieją także rozszerzenia api wyspecyfikowane przez konkretnego producenta np cl\_intel\_mem\_force\_host\_memory, które jest dostępna na urządzeniach intela, lub cl\_qcom\_android\_native\_buffer\_host\_ptr dostępny na procesorach Qualcoma z systemem Android. Takie dodatkowe api uzupełnia podstawę, umożliwiając lepsze dopasowanie specyfikacji do konkretnego sprzętu. OpenCL na platformie Android dostępny jest jedynie z poziomu natywnej biblioteki w języku c++.

\label{chap:goal}
\subsection{Linkowanie biblioteki OpenCL na platformie Android}
Aplikacje zwykle nie linkują się bezpośrednio ze sterownikiem posiadającym kompletną implementacje api. Do tego wykorzystywana jest dodatkowa biblioteka która wyszukuje implementacji sterownika dla wszystkich platform na urządzeniu. Dzięki wykorzystaniu takiej ładującej biblioteki Aplikacja może używać każdej dostępnej platformy wspierającej to Api, oraz nie jest na sztywno połączona z jednym sterownikiem w określonej wersji.
Niestety nie istnieje binarna wersja takiej biblioteki dla systemu Android. Istnieje możliwość połączenia natywnej biblioteki ze sterownikiem znajdującym się w urządzeniu, jednak wadą takiego rozwiązania jest konieczność pobrania z urządzenia pliku binarnego z implementacją OpenCL oraz wszystkich zależnych od niej sterowników. Takie rozwiązanie powoduje, że skompilowana aplikacja będzie działać jedynie na urządzeniu, z którego zostały pobrane biblioteki.
Innym rozwiązaniem jest pobranie źródeł z kodem biblioteki ładującej, zbudowanie biblioteki i połączenie jej z aplikacją. Sterownik który będzie łączył program z implementacją OpenCL ma zapisane domyślne ścieżki w których mogą znajdować sie biblioteka OpenCL. Istnieje również możliwość zdefiniowania zmiennej środowiskowej w której wskazujemy lokalizację z której chcemy by sterownik został załadowany. Wadą takiego rozwiązania jest konieczność kompilacji takiej biblioteki, natomiast dzięki temu możemy zbudować aplikację działającą na wielu urządzeniach.
https://github.com/krrishnarraj/libopencl-stub

\subsection{Typowy przebieg aplikacji OpenCL}
Poniżej widać jak wygląda przebieg prostego programu wykoystującego Api OpenCL do inkrementowania każdego elementu bufora pamięci.

\lstinputlisting{listings/sample_cl.cpp}

Pierwszym krokiem jest zawołanie \textbf{clGetPlatformIDs}. Podając drugi argument czyli cl\_platform\_id\* jako null, do trzeciego argumentu jakim jest cl\_uint\* zostanie wpisana liczba dostępnych na urządzeniu platform wspierajacych OpenCL.
Drugie wywołanie clGetPlatformIDs wpisze informacje o podanej liczbie platform i zapisze je w tablicy podanej w drugim argumencie.
W tej pracy w testowanych aplikacjach na system android wykorzystywany będzie CL\_DEVICE\_TYPE\_GPU, który jako jedyny jest dostępny na testowanych przeze mnie urządzeniach.
Posiadając obiekt device, wołając \textbf{clCreateContext} możemy stworzyć context w ramach którego możliwe jest zarządzanie poziej stworzonymi obiektami na określonych przy tworzeniu contextu urządzeniach. 
Dalej w przykłądowym kodzie storzona jest kolajka \textbf{clCreateCommandQueue} kolejka powstaje w ramach contextu na kontretny device. Póżniej na tym obiekcie kolejkowane będą zadania takie jak transfery pamieci czy wykonywane funkcje. W zależności czy kolejka zostanie stworzona z flagą CL\_QUEUE\_OUT\_OF\_ORDER\_EXEC\_MODE\_ENABLE lub bez niej, zadania te będą mogły być wykonywane równolegle, lub jedo po drugim w kolejnosci dodania do kolejki.
Kolejnym krokiem w powyższym kodzie jest stworzenie obiektu programu używajac \textbf{clCreateProgramWithSource} lub \textbf{clCreateProgramWithBinary} pierwsza stworzy program zawierający nieskompilowany kod w języku OpenCL C, natomiast druga stworzy obiekt z binarnej wersji, wcześniej skompilowanej. Do stworzenia programu ze źródeł przekazywany jest ciąg znaków zawierający kernele, czyli funkcje które mogą zostać wykonane na urządzeniu.
Do wykonania inkrementacji kazdego elementu bufora w przykładnie uzyty zostanie nastepujący kernel
\lstinputlisting{listings/increment.cl}
W funkcji tej zostaje pobrany unikalny numer aktualnie wykonywanego kernela w ramach globalnej work grupy, nastepnie element bufora pod tym indeksem jest inkrementowany. 
Po stworzeniu programu zawierającego kernele, należy zawołać \textbf{clBuildProgram} by kod kerneli w języku OpenCL C został skompilowany dla wskazanego urządzenia. W przypadku stworzenia programu ze źródeł w formie binarnej, tego kroku się nie wykonuje.
Nastepnym wykonanym krokiem jest stworzeniem obiektu bufora poprzez \textbf{clCreateBuffer}. Stworzeony zostaje obiekt reprezenujący obszar pamięci o podanym rozmiarze, który może być wykorzystany przy wykonywaniu kernela. W podanym kodzie powstanie buffor o rozmiarze 4096 bajtow czyli 1024 elementów typu int.
Następnie zostaje wykonane \textbf{clEnqueueMapBuffer} funkcja ta zmapuje konkretny buffor na obszar pamięci dostępny z poziomu aplikacji. W tym przypadku w pamięci pod zwróconym wskaźnikiem ustawiamy w każdym bajcie wartość 13.
By przesłać pamięć z pwrotem do obiektu bufora dostępnego z poziomu urządzenia na którym będzie wykonywany kernel wołamy \textbf{clEnqueueUnmapMemObject}.
Tak przygotowany bufor z danymi możemy ustawić jako argument kernela wołając \textbf{clSetKernelArg} podając w argumentach kernel, który w którym chcemy ustawić argument, index argumentu, jego typ oraz wskaźnik na obiekt który będzie argumentem funkcji.
Funkcja która uruchomi wykonanie kernela na wskazanym wczesniej urządzeniu jest \textbf{clEnqueueNDRangeKernel}, która umieści w kolejce do wykonywania wskazany kernel. W tym momencie podane jest także w ilu wymiarach odbędzie sie wykonywanie, podana jest wielkość lokalnej i globalnej work grupy.
Na samym końcu zawłoanezostaje \textbf{clFinish}, jest to funkcja blokująca po wykonaniu której mamy pewność, że wszystkie zakolejkowane na konkretnej kolejce operacje zostały wykonane.
W wynuku działania takiego kodu w buforze znajdować się bedzie 1024 elementy o wartości 13131314.
\subsection{Możliwości i ograniczenia sprzętowe}
Każde urządzenie posiada ograniczenia związane ze specyfiką implementacji sterownika oraz barkiem zasobów sprzętowych. By dowiedziec się jakie są maksymalne dostępne wartosci np dotyczące rozmiaru pamięci, ilości poszczególnych obiektów w kernelu czy maksymalnej liczbie dostępnych work itemów w ramak lokalnej work grupy możemy odpytać sterownik wołając clGetDeviceInfo podając konkretny parametr. Dzięki temu wykonywana aplikacja może dostosować się do ograniczeń sprzętowych. Oto wynik działania aplikacji "clinfo", która wypisuje wszystkie odstępne informacje o urządzeniu. W tym wypadku jest to telefon Xiaomi Mi a2 lite z procesorem graficznym Adreno 506
 \lstinputlisting{listings/clinfo.log}
 \subsection{Pomiary czasu wykonywania kerneli}
 Standard OpenCL zapewnia mechanizm do odczytywania stempli czasu z poszczególnych etapów wykonywania kernela. Służy do tego obiekt typu cl\_event stworzony przez funkcje clCreateUserEvent. Obiekt taki może zostać przekazany jako argument funkcj, która zostanie wykonana na urzadzeniu np clEnqueueNDRangeKernel czy clWnqueueWriteBuffer.
 Po wykonaniu kernela z obiektu eventa mozna odczytać stemple czasu z jego wykonania. By wydobyc wartości należy zawołać clGetEventProfilingInfo przekazujac jako argument obiekt eventu oraz jeden z czterech paramterów 
 \begin{itemize}
     \item CL\_PROFILING\_COMMAND\_QUEUED wartość opisuje czas urządzenia w którym komenda została dodana do kolejki.
     \item CL\_PROFILING\_COMMAND\_SUBMIT wartośc opisuje czas urządzenia w którym komenda została wysłana do urządzenia na którym zostanie wykonana.
     \item CL\_PROFILING\_COMMAND\_START wartośc opisuje czas urządzenia w którym rozpoczęte zostało wykonywanie komenty na urządzeniu.
     \item CL\_PROFILING\_COMMAND\_END wartośc opisuje czas urządzenia w którym wykonywanie komendy zostaje zakończone.
\end{itemize}
\subsection [Wspoldzielenie obiektów pomiędzy OpenCL i OpenGL]{Wspoldzielenie obiektów pomiędzy OpenCL i OpenGL}
OpenGL czyli Open Graphics Library to standard, ktory tak jak OpenCL jest zdefiniowany i utrzymywany orzez grupę Khronos. Jest on wykorzystywany głównie do renderowania obiektow graficznych.
Istnieje możliwość stworzenia textury w OpenGL i użycie tego w kernelu OpenCL. Nie wszystkie urządzenia wspierają współdzieleie zasobów, urządzenie wspiera wspoldzielenie jesli w liscie rozszeżeń znajduje sie cl\_khr\_gl\_sharing. By móc skorzystać z tej możliwości, context w OpenCL musi zostać stworzony w oparciu o wcześniej stworzony context OpenGL. Przy tworzeniu contextu podajemy strukturę, wktorej umieszcone są wskaźniki na kontekst w OpenGL i uchwyt na EGLDisplay. 
 \lstinputlisting{listings/contextProperties.txt}.
 Posiadając tak stworzony kontekst, możemy stworzyć obiekt obrazka w OpenCL w oparciu o stworzoną teksture w OpenGL
 \lstinputlisting{listings/sharedImage}. gdzie textureId to identyfikator tekstory, ktora chcemy wspoldzielic z openGL. 
 Przed wykorzystaniem wspoldzielonego obrazka należy zawołać clEnqueueAcquireGLObjects wskazując kolejke, kóra będzie używać obrazka. Jest to wykonywane w celu wywłaszczenia obiektu przez OpenCL. Po zakończeniu operacji na obiekcie należy go zwolnić poleceniem clEnqueueReleaseGLObjects.

